
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Change The World</title>
    
    <meta name="author" content="Eli Qiao">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Bootstrap styles -->
    <link href="/assets/themes//bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Optional theme -->
    <link href="/assets/themes//bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- Sticky Footer -->
    <link href="/assets/themes//bootstrap/css/bs-sticky-footer.css" rel="stylesheet">
    
    <!-- Custom styles -->
    <link href="/assets/themes//css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div id="wrap">
      <nav class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Eli Qiao's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="jb-navbar-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
      	
      	<li><a href="/archive">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages">Pages</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags">Tags</a></li>
      	
      
    
  




          </ul>
          <form class="navbar-form navbar-right" role="search">
            <div class="form-group">
              <input type="text" class="form-control" placeholder="Search">
            </div>
            <button type="submit" class="btn btn-default">Submit</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </nav>
      <div class="text clearfix" style="text-align:center;">
      </div>
      <div class="container" id="left" style="border: left;">
        
<div class="page-header">
  <h1>Change The World </h1>
</div>

<div class="row">
  <div class="col-xs-12">
    <ul>
    
    <li><span>27 Nov 2017</span> &raquo; <a href="/2017/11/27/tcp">TCP connection</a></li>
        
TCP

TCP 是传输层的一个协议，用来提供可靠传输。

TCP 报文定义见下图：



TCP 与 IP 协议一起工作，用于应用进程之间的通信。

TCP 的基本概念

三次握手与四次挥手



三次握手

由客户端发起连接请求，服务端相应请求并向客户端发起请求确认，客户端返回确认请求。
此时连接建立。


  第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
  第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
  第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。


假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。
采用“三次握手”的办法可以防止server由于重传导致的老的报文一直等待client发来数据。这样，server的很多资源就白白浪费掉了现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。

四次挥手



TOOD

Socket 各种状态分析

TODO

  TIME_WAIT
  …

<br />
            <a href="/2017/11/27/tcp">Read more...</a><br /><br />
    
    <li><span>26 Jul 2015</span> &raquo; <a href="/lessons/2015/07/26/vote-url">Vote Url</a></li>
        Tokyo summit vote url 您可以直接点击以下链接进行投票。 Towards Robust Live Migration in Dynamic Environments OpenStack Practice @ Intel IT: Let’s accelerate the design process of smart devices CI/CDaaS based on Magnum/Murano within Intel IT Private Cloud OpenStack DevOps in Intel IT: How to serve a private Cloud while continues contribute to community...<br />
            <a href="/lessons/2015/07/26/vote-url">Read more...</a><br /><br />
    
    <li><span>03 Jul 2015</span> &raquo; <a href="/lessons/2015/07/03/hacking-magnum-swarm-proxy">Hacking Magnum Swarm Proxy</a></li>
        Hacking magnum swarm node to add proxy I will talk about how to add proxy in magnum swarm framework Why I need proxy Because GFW, you know! Where to add proxy We need an http_proxy and https_proxy first! if you do not have that proxy, then you can leave now....<br />
            <a href="/lessons/2015/07/03/hacking-magnum-swarm-proxy">Read more...</a><br /><br />
    
    <li><span>23 Sep 2014</span> &raquo; <a href="/2014/09/23/vhost">Vhost net</a></li>
        Vhost 概述 Linux kernel 中的vhost driver提供了KVM在kernel环境中的virtio设备的模拟。vhost把QEMU模拟设备的代码放在了linux kernel里面，所以设备模拟代码可以直接进入kernel子系统，从而不需要从用户空间通过系统调用陷入内核，减少了由于模拟IO导致的性能下降。 vhost-net是在宿主机上对vhost 网卡的模拟，同样，也有vhost-blk，对block设备的模拟，以及vhost-scsi，对scsi设备的模拟。 vhost 在kernel中的代码位于 drivers/vhost/vhost.c Vhost 驱动模型 vhost driver创建了一个字符设备 /dev/vhost-net，这个设备可以被用户空间打开，并可以被ioctl命令操作。当给一个Qemu进程传递了参数-netdev tap,vhost=on 的时候，QEMU会通过调用几个ioctl命令对这个文件描述符进行一些初始化的工作，然后进行特性的协商，从而宿主机跟客户机的vhost-net driver建立关系。 QEMU代码调用如下： vhost_net_init -&gt; vhost_dev_init -&gt; vhost_net_ack_features 在vhost_net_init中调用了 vhost_dev_init ，打开/dev/vhost-net这个设备，然后返回一个文件描述符作为vhost-net的后端， vhost_dev_init 调用的ioctl命令有 r = ioctl(hdev-&gt;control, VHOST_SET_OWNER, NULL); Kernel 中的定义为： 1. /* Set current process as the (exclusive) owner of this file...<br />
            <a href="/2014/09/23/vhost">Read more...</a><br /><br />
    
    <li><span>18 Sep 2014</span> &raquo; <a href="/lessons/2014/09/18/request-data-flow">Request Data Flow</a></li>
        Data flow of openstack request This post will talk about the data flow of an openstack request, I will take boot an instance and shelve an instance as example. Assume that you have setup an openstack environment already. Let’s start from nova client, you can put –debug option to nova...<br />
            <a href="/lessons/2014/09/18/request-data-flow">Read more...</a><br /><br />
    
    <li><span>14 Aug 2014</span> &raquo; <a href="/lessons/2014/08/14/deploy-openstack-with-packstack">Deploy Openstack With Packstack</a></li>
        使用packstack部署openstack 本文将介绍如何使用Redhat提供的packstack部署openstack Openstack 简介 openstack 是一整套资源管理软件的集合，也是当前最热的开源虚拟化管理软件之一，有一个全球139个国家将近两万开发者参与的开源社区（www.openstack.org）作为支持。openstack项目的目的是快速建设一个稳定可靠的公有云或私有云系统。整个项目涵盖了计算，存储，网络以及前端展现等关于云管理的全部方面，包含了众多子项目。 主要包含了一下几个子项目: OpenStack Compute (code-name Nova) 计算服务 OpenStack Networking (code-name Neutron) 网络服务 OpenStack Object Storage (code-name Swift) 对象存储服务 OpenStack Block Storage (code-name Cinder) 块设备存储服务 OpenStack Identity (code-name Keystone) 认证服务 OpenStack Image Service (code-name Glance) 镜像文件服务 OpenStack Dashboard (code-name Horizon) 仪表盘服务 OpenStack Telemetry (code-name Ceilometer) 告警服务...<br />
            <a href="/lessons/2014/08/14/deploy-openstack-with-packstack">Read more...</a><br /><br />
    
    <li><span>13 Jun 2014</span> &raquo; <a href="/2014/06/13/linux-interrupt">Linux Interrupt</a></li>
        
Linux 中断
中断硬件发起，外部设备与cpu通信的一种方式，相对于cpu轮询，中断是更好的方式。
中断设备与cpu的物理连接方式如下：



一般来说，外设并不直接与cpu相连接，而是通过一个叫’中断控制器’硬件连接。这个中断控制器是可被编程配置的。
所以又称它为’可编程中断控制器’（PIC）。外设向中断控制器发起中断，然后，’中断控制器’告诉cpu有中断到来。
cpu去读取中断控制器（PIC）产生的软中断号。
初始化需要配置PIC，配置内容包括：


  中断触发的电信号类型（水平还是边沿触发）
  将外设的引脚编号映射到cpu可见的软件中断号irq
  屏蔽掉某些外部设备的中断触发


中断向量表

中断向量表是cpu的内部概念。当发生 ‘异常’ 或者 ‘内部中断’时，cpu会查看中断向量表该异常或者中断对应的处理函数地址。

通用中断处理函数

通常，当发生外部设备中断时，外设向中断控制器产生一个中断，中断控制器生成一个软件中断信号通知cpu。cpu发现是一个外部
中断，他会查询中断向量表中的某一表项去处理该中断。该表项对应的就是通用中断处理函数的入口地址。操作系统会提供这个通
用中断处理函数的定义。

通用中断处理函数的处理过程大致为：


  获取软件中断号irq，一般使用汇编编写。
  调用do_irq，c函数编写


所以，当一个外部设备产生中断后，到cpu响应该中断的流程如下：

  外设触发一个中断
  中断控制器（PIC）获取中断号并报告给cpu
  cpu得知这是一个外部中断，它去查找他的中断向量表，找到通用中断处理函数的地址
  cpu调用中断处理函数，通过向PIC查询软中断号
  中断处理函数通过软中断号找到该外设注册的中断处理子函数（由驱动提供,在irq_desc数组中）


HARDIRQ 和 SOFTIRQ

当cpu在响应一个中断的时候，如果有新的中断到来了，如何处理呢？
cpu为了处理这种情况，将中断处理分成了上半部和下半部。
HARDIRQ在中断关闭情况下执行，他的执行时间尽可能短
SOFTIRQ在中断开启的情况下执行。此时外部设备仍可以继续中断处理器，一般驱动程序可以将耗时部分放在此部分执行。

<br />
            <a href="/2014/06/13/linux-interrupt">Read more...</a><br /><br />
    
    <li><span>10 Jun 2014</span> &raquo; <a href="/lessons/2014/06/10/use-cloud-image-locally">Use Cloud Image Locally</a></li>
        如何在本地使用cloud镜像 fedora，ubuntu等发行版厂商提供了各自cloud的镜像文件，我们可以直接下载并将其运行为一个虚拟机实例。 但是这些cloud镜像文件默认磁盘分区大小可能无法满足我们的需求，而且，默认是不提供通过密码访问的方式访问虚拟机。 本文将介绍如何快速修该磁盘分区大小以及访问虚拟机。 本文中使用的环境为fedora 20，并且需要libguestfs-tools提供的工具，使用如下命令安装。 sudo yum install libguestfs-tools -y 首先获取image，使用国内163网站的镜像服务器下载fedora20的镜像文件: wget https://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2.xz xz -v --decompress CentOS-7-x86_64-GenericCloud.qcow2.xz 因为libguestfs工具以来libvirt启动虚拟机来进行编辑镜像文件，所以我们要把镜像文件放在/var/lib/libvirt/images目录下。 查看镜像文件大小，并对其进行扩展 $ virt-filesystems --long --parts --blkdevs -h -a CentOS-7-x86_64-GenericCloud.qcow2 Name Type MBR Size Parent /dev/sda1 partition 83 1.9G /dev/sda /dev/sda device - 2.0G - $ virt-df -h CentOS-7-x86_64-GenericCloud.qcow2 Filesystem Size Used...<br />
            <a href="/lessons/2014/06/10/use-cloud-image-locally">Read more...</a><br /><br />
    
    <li><span>09 Jun 2014</span> &raquo; <a href="/lessons/2014/06/09/linux-network-namespace">Linux Network Namespace</a></li>
        Linux Network Namespaces Linux kernel在2.6.29中加入了namespaces，用于支持网络的隔离，我们看一下namespace是如何使用的 创建与配置 创建一个名为blue的namespace ip netns add blue 列出所有的namespace ip netns list 分配网络接口到namespace上 我们可以将一对veth中的一个分配到namespace上，将另一个分配到另一个上。 veth的创建如下： ip link add veth0 type veth peer name veth1 这样就创建了一对veth，veth0 和veth1。 veth的作用就像一根网线一样，从一端进入的数据会从另一端出来。 使用 ip link list 查看创建的veth设备。 如果我们想把刚创建的namaespace与global/default namespace连接，我们可以这样做： ip link set veth1 netns blue veth1 从global从消失了,因为这对veth的另一端veth0在default中，这样我们就可以将两个 namespace联系起来了。 使用如下命令查看blue namespace中的连接 ip netns...<br />
            <a href="/lessons/2014/06/09/linux-network-namespace">Read more...</a><br /><br />
    
    <li><span>06 Jun 2014</span> &raquo; <a href="/2014/06/06/linux-pci">Linux PCI</a></li>
        PCI 简介 PCI(Periheral Component Interconnect)有三种地址空间：PCI I/O空间、PCI内存地址空间和PCI配置空间。 I/O 空间和内存地址空间由PCI驱动使用。 PCI配置空间由Linux PCI初始化代码使用，由内核用来进行配置，比如中断号和I/O内存基址空间。 PCI 桥 一共有三种PCI桥： HOST/PCI桥（HOST bridge）：用于连接CPU和PCI的桥设备 PCI/ISA桥 （ISA bridge）：用于连接PCI总线和ISA总线的桥 PCI-PCI桥（PCI-PCI bridge）：用于PCI总线的扩展 下图展示了pci桥的层次连接： 在使用PCI设备之前,Linux Knerle需要对其进行枚举和配置。 枚举的结果就将是一个树状的结构，根是HOST/PCI桥。 配置PCI设备 Linux kernel 对PCI配置空间进行配置。这个PCI配置空间其实就是一些寄存器，称为配置寄存器组。 当PCI设备尚未被激活的时候，它只对配置事务响应。设备上是不会有I/O端口映射到计算机的内存空间的。 中断也会被禁止。 PCI设备的地址空间 所有PCI设备的配置空间寄存器组都采用相同的地址，由总线的PCI桥在访问时附加上其他条件进行区分。 对于CPU来说，它通过一个统一的入口地址HOST/PCI桥，即树型结构的根发出指令，再由相应的PCI桥间接地完成具体的读写。 这个PCI桥（或者称PCI总线）包含两个寄存器，’地址寄存器’和’数据寄存器’，CPU向’地址寄存器’写入要访问的地址，然后通过’数据寄存器’读取数据。 地址寄存器的地址组成： 总线号：设备号：功能号：寄存器号 示例，lspci 输出： 0000 : PCI domain (each domain can contain up to 256 PCI...<br />
            <a href="/2014/06/06/linux-pci">Read more...</a><br /><br />
    
    <li><span>06 Jun 2014</span> &raquo; <a href="/lessons/2014/06/06/fedora-live-upgrade">Fedora Live Upgrade</a></li>
        Fedora 在线升级
所需工具工具 fedup
fedup的安装
$sudo yum install fedup

fedup装成功后，推荐使用网络方式升级系统

$sudo fedup-cli --network 20 --addrepo f20=http://mirrors.163.com/fedora/releases/20/Everything/x86_64/os/

<br />
            <a href="/lessons/2014/06/06/fedora-live-upgrade">Read more...</a><br /><br />
    
</ul>


  </div>
</div>


      </div>

    </div>
    <div id="footer">
      <div class="container">
        <p>&copy; 2018 Eli Qiao 
           &copy; email: taget@163.com
           &copy;  Hakder友情链接： <a href=" http://chris.yeoh.info" target="_blank">Chris Yeoh</a> & 
           <a href="http://soulxu.github.io/" target="_blank">Alex Xu</a>
        </p>
      </div>
    </div id="footer">

    


    <!-- Latest compiled and minified JavaScript, requires jQuery 1.x (2.x not supported in IE8) -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="/assets/themes//bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>

